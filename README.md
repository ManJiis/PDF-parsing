使用比较原始的方案实现RPC框架，采用Socket通信、动态代理与反射与Java原生的序列化。

RPC架构分为三部分：
- 服务提供者，运行在服务器端，提供服务接口定义与服务实现类。
- 服务中心，运行在服务器端，负责将本地服务发布成远程服务，管理远程服务，提供给服务消费者使用。
- 服务消费者，运行在客户端，通过远程代理对象调用远程服务。

https://gitee.com/dromara/koalas-rpc

https://github.com/dromara/koalas-rpc

项目启动调用过程如下：
使用注解标注接口。
使用 zookeeper 作为注册中心。客户端从zk拉取可用的 IP 
客户端利用 spring 生成 代理类。  最终由代理类完成消息的序列化和发送。
服务端反射调用。
可以配置直连，也可以利用注册中心，获取一批的IP，然后进行负载均衡。  
基本上 JavaRPC 框架都是这个套路：
先定义协议，一般是一个接口。
服务端实现这个接口。
客户端直接引用这个接口jar包。 因为客户端调用的仅仅是一个接口，所以在调用之前，RPC框架要为这个接口生成了一个代理类， 在实际调用的时候，其实调用的是这个代理类，这个代理类代理的方法都是一个实现：就是将调用的信息（调用的类，方法，参数）进行封装。
然后获取所有的实现这个接口的服务端 IP(对应集群管理模块)。
从这些IP 中选择一台(对应负载管理模块)。
对调用信息序列化(序列化模块)。
最后发送(网络通信模块，http/tcp)。
 
对于服务端
扫描所有接口实现，将接口信息，连同服务器信息(IP、端口)一起注册到注册中心。
建立侦听。
获取到请求。
反序列化报文 。
解析出要调用的类，方法，参数，然后通过反射调用目标类和方法，并传递参数进去。 当然出于一定的目的也会对服务端的实现做一定的增强。 
 
所以一般的 RPC 实现，都是客户端使用代理实现，对应代理的实现方式，dubbo 使用的是Javassist，koalas-rpc使用的是 spring中 的功能。